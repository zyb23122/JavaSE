## Java基础语法

### 标识符

字母、数字、$、_ 。命名不能以数字开头，不能是关键字。

### 命名规范

类名规范：首字母大写，后面每个单词首字母大写（大驼峰式）。

变量名规范：首字母小写，后面每个单词首字母大写（小驼峰式）。

方法名规范：小驼峰式。

### 修饰符

访问控制修饰符：default、public、protected、private

非访问控制修饰符：final、abstract、static、synchronized

### 变量类型

局部变量--与方法的生命周期相同。

实例变量--与对象的生命周期相同。

静态变量--生命周期与类相同。

注意：float和long的字母后缀F和L不能丢。先赋值，再使用。

### 常量

字符串常量："abc"

整数常量：12

浮点数常量：2.6

字符常量：'A','中'  （输出时两个单引号中间必须有且仅有一个字符，没有不行。）

布尔常量：true、false

空常量：null        （空常量不能直接打印输出）

## 数据类型

### 基本数据类型

#### 整型

byte：1个字节，-128~127

short：2个字节，-32768~32767

int（默认）：4个字节

long：8个字节

#### 浮点型

float：4个字节

ps：float f=1.3；语句错误。在Java语言中，对于实型数值，默认的类型是 double型的，若要把它赋给float变量，必须对它进行类型转换，赋初值的话，必须在实型数后面加上f或F字母。

double：8个字节

ps：float和double因为使用的是科学计数法，所以数据范围比long广

#### 字符型

char：2个字节

#### 布尔型

boolean：true、false。一个字节

#### 类型转换

自动类型转换：byte,short,char->int->long->float->double

强制类型转换：变量之间使用强转，

```java
int a=10;
byte b=(byte)a;但是+=会自动转换数据类型
```

一般不使用强转，可能会精度缺失，数据溢出

byte/short/char都可以发生数学运算，例如加法“+”，运算时，都会被先提升为int型，再计算。

ASCII表 '0'--48   'A'--65  'a'--97

### 引用数据类型

#### 类class

具有共同属性和行为的对象的集合，利用多态性 : 可以当做父类引用指向子类对象。

#### 接口interface

接口在程序中类似于是一种约束,规范（降低耦合）

接口的实现（implement）：子类要重写全部的抽象方法；如果不实现或者没有重写完,子类要变为抽象类；一个类支持实现多个接口；一个类可以在继承另一个类的同时实现多个接口。

default方法：在接口内部包含了一些默认的方法实现（也就是接口中可以包含方法体，这打破了Java之前版本对接口的语法限制），从而使得接口在进行扩展的时候，不会破坏与接口相关的实现类代码。适用于后期项目代码的维护。

#### 数组

##### 一维数组

声明：数据类型[ ]  数组名;

创建：动态创建：数组名 = new 数据类型[长度];

​            静态创建：数组名 = new 数据类型[]{元素1,元素2,...};

赋值：数据类型 变量名 = 数组名[下标];

​            数组名[下标] = 值;（int[] v = { 5, 7, 23, 9, 231 };）

##### 二维数组

int[][] a = new int[][] { { 1, 2, 3, 3, 9, 9 }, { 4, 5, 6 }, { 7, 8, 9, 10 }, { 1 } };

##### 数组工具类Arrays

String v=Arrays.toString(数组); 将数组元素以字符串的形式返回

 Arrays.sort(数组); 将数组升序排序

（类名直接调用方法，是因为该方法是静态方法）

题目：使用Arrays相关的API，将一个随机字符串中的所有字符升序排列，并倒序打印

```java
public class ArrayTest {
    public static void main(String[] args) {
        String str="auiaruhifanv";
        char[] chars=str.toCharArray();
        Arrays.sort(chars);
        for (int i = chars.length - 1; i >= 0; i--) {
            System.out.println(chars[i]);
        }
    }
}

```

##### 冒泡排序

```java
for (int i = 0; i < list.length - 1; i++) {
            // 每一轮比较多少个
            for (int j = 0; j < list.length - 1 - i; j++) {
                if (list[j] > list[j + 1]) {
                    // 交换次序
                    temp = list[j];
                    list[j] = list[j + 1];
                    list[j + 1] = temp;
                }
            }
}
```



##### 快速排序（分治法）

给基准数据找其正确索引位置的过程.

```java
void quick_sort(int s[], int l, int r)
{
    if (l < r)
    {
        //Swap(s[l], s[(l + r) / 2]); //将中间的这个数和第一个数交换 参见注1
        int i = l, j = r, x = s[l];
        while (i < j)
        {
            while(i < j && s[j] >= x) // 从右向左找第一个小于x的数
                j--;  
            if(i < j) 
                s[i++] = s[j];
            
            while(i < j && s[i] < x) // 从左向右找第一个大于等于x的数
                i++;  
            if(i < j) 
                s[j--] = s[i];
        }
        s[i] = x;
        quick_sort(s, l, i - 1); // 递归调用 
        quick_sort(s, i + 1, r);
    }
}
```



## 流程控制语句

### 循环

while

```java
while(布尔表达式){
   //循环内容
}
```

do...while （至少执行一次）

```java
do{
    //循环内容
}while(布尔表达式)
```

for

```java
for(初始化;布尔表达式;更新){
   // 循环内容
}
```

增强的for循环

```java
int[] numbers = {10, 20, 30, 40, 50};        
for(int x : numbers ){
         System.out.print( x );
         System.out.print(",");
      }
```

break：跳出循环

continue：结束本次循环，进入下次循环

死循环：

```java
while(true){
            循环体
        }
```

### 条件

if...else

```java
if(布尔表达式)
{
   //如果布尔表达式为true将执行的语句
}else{
   //如果布尔表达式的值为false
}
```

if...else if...else

```java
if(布尔表达式 1){
   //如果布尔表达式 1的值为true执行代码
}else if(布尔表达式 2){
   //如果布尔表达式 2的值为true执行代码
}else if(布尔表达式 3){
   //如果布尔表达式 3的值为true执行代码
}else {
   //如果以上布尔表达式都不为true执行代码
}
```

嵌套的if...else

```java
if(布尔表达式 1){
   ////如果布尔表达式 1的值为true执行代码
   if(布尔表达式 2){
      ////如果布尔表达式 2的值为true执行代码
   }
}
```

switch

```java
switch(grade)                
      {
         case 'A' :
            System.out.println("优秀"); 
            break;
         case 'B' :
         case 'C' :
            System.out.println("良好");
            break;
         case 'D' :
            System.out.println("及格");
            break;
         case 'F' :
            System.out.println("你需要再努力努力");
            break;
         default :
            System.out.println("未知等级");
      }
```

switch小括号内的内容：基本数据类型：byte/short/char/int    引用数据类型：String字符串、enum枚举 

case后面的值不可以重复

switch语句格式可以很灵活：前后顺序可以颠倒，而且break语句可以省略。（匹配哪一个case就从哪一个位置向下执行，直到遇到break或者整体结束为止）

```java
注意：char c = 'A' ;
        int num = 10 ;
        switch(c) {
            case 'B' :
                num ++ ;
            case 'A' :
                num ++ ;
            case 'Y' :
                num ++ ;
                break ;
            default :
                num -- ;
        }
        System.out.println(num) ;
这个程序执行到 case 'A' :
                num ++ ;后没有break；语句穿透 case 'Y' :继而执行num ++ ;
                break ;
```

## 运算符

### 算数运算符

++在前，先自增，再使用；++在后，先使用，再自增

### 关系运算符

==   !=  > <   >= <=

### 取模运算符

%   取余数

### 逻辑运算符

&：全真为真

|：全假为假

！：逻辑非

&&：因为&是一错就错,所以当&&前已经是false时,那么就可以确定整体表达式的结果是false，后续的表达式就不再执行了

||：短路或，同上。只要第一个表达式的结果能确定整体表达式的结果,后面表达式就短路不执行.

### 三目运算符

数据类型 变量 = 布尔表达式 ?当前面结果是true时执行此处:当前面结果是false时执行此处;

```java
int s = a < b ? 1 : 0;  a<b时，s=1；a>b时，s=0
```

### 运算符优先级

由高向低分别是：()、!、算术运算符、关系运算符、逻辑运算符、赋值运算符；

## 修饰符

### 访问修饰符

public：被public修饰的属性和方法可以在任意位置被访问

protected：在本类中,同一包不同类中,不同包中的子类对象可以访问

package(缺省/默认)：在本类中,在同一包

private：在本类中访问

### static

#### 修饰属性和方法

##### 属性

会随类加载而初始化

内存只有一份

该属性变为类属性

##### 方法

会随类加载而初始化

内存只有一份

调用静态属性/方法

静态方法中不能使用this

### final

修饰类 : 类不能被继承

修饰属性 : 属性不能被改变,变为常量

修饰方法 : 方法不能被重写，更不能被调用

### abstract

抽象，被子类继承

子类继承抽象类,重写全部的抽象方法

如果子类不重写或者没有重写完抽象方法,子类也必须是抽象类

抽象类不能创建对象,但是可以利用多态性 当做父类引用指向子类对象

## 关键字

### super

使用位置 : 在非静态方法中使用

是什么 : 当前对象的父类对象

作用：

1. 调用父类的属性 super.属性名

2. 调用父类的方法 : super.方法名()

3. 调用父类构造方法

### this

使用位置 : 非静态方法中使用

是什么 : 代表当前调用这个方法的对象

this调用构造方法只能在第一行，唯一一个

作用：

调用属性 : this.属性名

    1. 子类该属性,调用的是子类本身的属性
       2. 该属性子类没有,调用的是父类的属性

调用方法 : this.方法名()

1. 当自己有该方法时,调用的是自己的方法

2. 自己没有该方法时,调用的是父类的方法

调用构造方法 : this()

### final

修饰类 : 类不能被继承

修饰属性 : 属性不能被改变,变为常量

修饰方法 : 方法不能被重写

### static

#### 修饰属性和方法

##### 属性

会随类加载而初始化

内存只有一份

该属性变为类属性

##### 方法

会随类加载而初始化

内存只有一份

调用静态属性/方法

静态方法中不能使用this

## 构造方法

创建对象

为类中的属性赋值

无参构造：创建出的对象中的属性是该数据类型的默认初始值

```java
public Teacher(){

     System.out.println("空参构造方法执行了！");

   }
```

有参构造：创建出的对象中属性是构造方法中的参数值

```java
public Teacher(String name,int age){

     System.out.println("全参构造方法执行了！");

    this.name=name;

    this.age=age;

   }
```

特点：

1.没有返回值,也没有void

2. 方法名是该类的类名

3. 默认第一行隐式存在super();,调用父类无参构造,创建父类对象

4. 虽然是方法,但是不能被对象调用

每个类默认提供无参构造,但是显式写出任何一个构造方法,默认的不再提供



## 代码块

### 静态代码块

static {} 在类中方法外，随着类的加载而加载

### 构造代码块

{} 在类中方法外 ，每次调用构造方法前会执行该代码块

### 局部代码块

{} 在方法内  ，可以及时释放资源

#### 总结：

静态代码块>构造代码块>构造方法>普通方法>局部代码块

ps：当类有继承时，父类会先加载到内存，再加载子类。

## 重写和重载

### 重写Override

1 访问修饰符的权限子类的 >=父类

2 返回值一样,（如果返回值不一样 : 子类的返回值数据类型可以向上转型为父类方法的返回值数据类型）

3.参数列表 与父类一样

4.子类抛出的异常范围要比父类异常范围小

### 重载Overload

方法名相同,参数列表（参数个数、类型、顺序）不同的方法

使用方法的时候可以只通过一个方法名,传入不同的参数就有结果.不用因为不同的参数而去调用不同方法,给使用者提供便利

## 封装

隐藏实现细节,只对外提供公共访问的方法

1.属性私有化(private修饰)

2.提供set get方法

## 继承

  子类可以使用父类非私有的属性和方法

java 的类是单继承

继承中子类与父类的属性与方法的访问问题：

属性：

子类无属性,父类有属性。子类可以直接访问父类属性。等号左边是谁，就优先用谁，没有则向上找

子类有与父类一样的属性(数据类型 属性名一致)，1. 子类对象默认访问自己的属性，2. 使用super.属性名 访问父类的属性。

方法：

子类无此方法,父类有方法，子类对象可以直接方法父类方法。该方法属于谁，就优先用谁，没有则向上找。

子类有此方法,父类也有此方法(子父类方法一模一样)。1. 子类对象默认调用的是自己的方法。2. super.方法名() 调用父类的方法

构造方法：

1. 子类对象不能直接调用父类构造方法

2. 子类的构造方法中第一行默认存在super() 调用父类构造方法

## 多态

#### 成立条件

1.继承

2.重写

3.父类引用指向子类引用

编译看父类,运行看子类

作用 : 利用多态性设计方法的时候,可以将方法的参数列表设计为父类或者父接口.调用方法传入参数时,可以传入不同的子类对象/实现类的对象,使该方法表现出不同的功能。

#### 用法

##### 成员变量的使用

1.直接通过对象名称访问成员变量：看等号左边是谁，优先用谁，没有则向上找。

2.间接通过成员方法访问成员变量;看该方法属于谁，优先用谁，没有则向上找。

间接通过成员方法访问成员变量;看该方法属于谁，优先用谁，没有则向上找。

##### 成员方法的使用

编译看左边，运行看右边。！！！！@！@！@！

调用静态方法看“=”左边，非静态看右边。

看new的是谁，就优先用谁，没有则向上找。

#### instanceof

获取一个父类引用的对象本来是什么子类。

对象  instanceof  类名称。

得到一个boolean结果，也就是判断前面的对象能不能当作后面类型的实例。

```java
if (animal instanceof Dog){

   Dog dog = (Dog) animal;

   dog.watchHouse();

}
```

判断父类引用animal本来是不是Dog，是就向下转型。

#### 转型

对象的向上转型：Fu fu = new Zi();

向上转型一定是安全的，类似于自动类型转换，小范围转为大范围。

对象的向下转型：Zi zi = (Zi) Fu;

其实是一个“还原”的动作，将父类对象还原成原来的子类对象，类似于强制类型转换。大范围转小范围。注意：必须本来就是Zi，才能还原成Zi。